#                                                            #
# This file is distributed as part of the WannierBerri code  #
# under the terms of the GNU General Public License. See the #
# file `LICENSE' in the root directory of the WannierBerri   #
# distribution, or http://www.gnu.org/copyleft/gpl.txt       #
#                                                            #
# The WannierBerri code is hosted on GitHub:                 #
# https://github.com/stepan-tsirkin/wannier-berri            #
#                     written by                             #
#           Stepan Tsirkin, University of Zurich             #
#   some parts of this file are originate                    #
# from the translation of Wannier90 code                     #
# ------------------------------------------------------------#

import functools
import warnings
import numpy as np
import multiprocessing

from .needed_data import NeededData

from ..fourier.rvectors import Rvectors
from ..utility import cached_einsum, real_recip_lattice, alpha_A, beta_A
from .system_R import System_R



def System_w90(
    w90data,
    transl_inv_JM=False,
    transl_inv_MV=False,
    fftlib='fftw',
    npar=None,
    wannier_centers_from_chk=True,
    symmetrize=False,  # temporary set to False, because there is a bug when the basis at different atoms is rotated # TODO FIXME
    ws_dist_tol=1e-5,
    **parameters
):
    """
    System initialized from the Wannier functions generated by `Wannier90 <http://wannier.org>`__ code.
    Reads the ``.chk``, ``.eig`` and optionally ``.mmn``, ``.spn``, ``.uHu``, ``.sIu``, and ``.sHu`` files

    Parameters
    ----------
    w90data : `~wannierberri.system.Wannier90data`
        object that contains all Wannier90 input files and chk all together. If provided, overrides the `seedname`
    transl_inv_JM : bool
        translational-invariant scheme for diagonal and off-diagonal matrix elements for all matrices. Follows method of Jae-Mo Lihm
    transl_inv_MV : bool
    Use Eq.(31) of `Marzari&Vanderbilt PRB 56, 12847 (1997) <https://journals.aps.org/prb/abstract/10.1103/PhysRevB.56.12847>`_ for band-diagonal position matrix elements
    Note : it applies only to the `AA` matrix for R+!=[0,0,0] and only if `transl_inv_JM` is False
    Kept for legacy reasons, as it is not used recommended to use. 

    wannier_centers_from_chk : bool
        If True, the centers of the Wannier functions are read from the ``.chk`` file. If False, the centers are recalculated from the ``.mmn`` file.
    npar : int
        number of processes used in the constructor
    fft : str
        library used to perform the fast Fourier transform from **q** to **R**. ``fftw`` or ``numpy``. (practically does not affect performance,
        anyway mostly time of the constructor is consumed by reading the input files)
    symmetrize : bool
        if True, the R-matrices and wannier centers are symmetrized (highly recommended, False is for debugging only)
        works only if initialized from the w90data object, and that object has the symmetrizer
    **parameters
        see `~wannierberri.system.System_R` and `~wannierberri.system.system.System` for the rest of the parameters

    Notes
    -----
    The R-matrices are evaluated in the nearest-neighbor vectors of the finite-difference scheme chosen.

    Attributes
    ----------
    _NKFFT_recommended : int
        recommended size of the FFT grid in the interpolation


    See Also
    --------
    `~wannierberri.system.system.System_R`
    """
    if transl_inv_MV:
        warnings.warn("transl_inv_MV is deprecated and will be removed in the future. "
                      "Use transl_inv_JM instead.")
    system = System_R(**parameters)
    if npar is None:
        npar = multiprocessing.cpu_count()
    needed_data = NeededData(**parameters)

    if transl_inv_JM:
        unknown = needed_data.not_in_list(
            ['Ham', 'AA', 'BB', 'CC', 'OO', 'GG', 'SS', 'SH', 'SHR', 'SHA', 'SA', 'SR'])
        if len(unknown) > 0:
            raise NotImplementedError(f"transl_inv_JM for {list(unknown)} is not implemented")
        # Deactivate transl_inv_MV if Jae-Mo's scheme is used
        if transl_inv_MV:
            warnings.warn("Jae-Mo's scheme does not apply Marzari & Vanderbilt formula for"
                          "the band-diagonal matrix elements of the position operator.")
            transl_inv_MV = False
    else:
        unknown = needed_data.not_in_list(
            ['Ham', 'AA', 'BB', 'CC', 'OO', 'GG', 'SS', 'SH', 'SHR', 'SHA', 'SA', 'SR'])
        if len(unknown) > 0:
            raise NotImplementedError(f"unknown matrices requested: {list(unknown)} is not implemented")

    w90data.check_wannierised(msg="creation of System_w90")
    if w90data.irreducible:
        symmetrize = True
    chk = w90data.chk
    system.real_lattice, system.recip_lattice = real_recip_lattice(chk.real_lattice, chk.recip_lattice)
    system.set_pointgroup(spacegroup=w90data.get_spacegroup())
    system.wannier_centers_cart = chk.wannier_centers_cart

    mp_grid = w90data.mp_grid
    system._NKFFT_recommended = mp_grid
    system.rvec = Rvectors(lattice=system.real_lattice, shifts_left_red=system.wannier_centers_red)
    system.rvec.set_Rvec(mp_grid=mp_grid, ws_tolerance=ws_dist_tol)
    system.num_wann = w90data.num_wann

    system.rvec.set_fft_q_to_R(
        kpt_red=w90data.kpt_latt,
        numthreads=npar,
        fftlib=fftlib,
    )

    #########
    # Oscar #
    #######################################################################

    # Compute the Fourier transform of matrix elements in the original
    # ab-initio mesh (Wannier gauge) to real-space. These matrices are
    # resolved in b, i.e. in the nearest-neighbor vectors of the
    # finite-difference scheme chosen. After ws_dist is applied, phase
    # factors depending on the lattice vectors R can be added, and the sum
    # over nearest-neighbor vectors can be finally performed.


    # H(R) matrix

    kptirr, weights_k = w90data.kptirr_system

    HHq = chk.get_HH_q(w90data.eig, kptirr=kptirr, weights_k=weights_k)

    system.set_R_mat('Ham', system.rvec.q_to_R(HHq))

    if needed_data.need_any('SS'):
        system.set_R_mat('SS', system.rvec.q_to_R(chk.get_SS_q(w90data.spn, kptirr=kptirr, weights_k=weights_k)))

    if wannier_centers_from_chk:
        system.wannier_centers_cart = w90data.wannier_centers_cart
    else:
        assert w90data.has_file('mmn'), "mmn file is needed to calculate the centers of the Wannier functions"
        AA_q = chk.get_AA_q(w90data.mmn, kptirr=kptirr, weights_k=weights_k)
        AA_R0 = AA_q.sum(axis=0) / np.prod(mp_grid)
        system.wannier_centers_cart = np.diagonal(AA_R0, axis1=0, axis2=1).T


    # Wannier centers
    centers = system.wannier_centers_cart
    # Unique set of nearest-neighbor vectors (cartesian)
    if w90data.has_file('mmn'):
        NNB = w90data.mmn.NNB
        if transl_inv_JM:
            bk_cart = w90data.mmn.bk_cart
            phaseR = cached_einsum('ba,Ra->Rb', bk_cart, - 0.5 * system.rvec.cRvec)
            expiRphase1 = np.exp(1j * phaseR)[:, None, None, :]
            expiRphase2 = expiRphase1[:, :, :, :, None] * expiRphase1[:, :, :, None, :]

        index_b = {1: [(ib,) for ib in range(NNB)],
                   2: [(ib1, ib2) for ib1 in range(NNB) for ib2 in range(NNB)]}
        dict_ib = {1: [{'ib': ib[0]} for ib in index_b[1]],
                2: [{'ib1': ib[0], 'ib2': ib[1]} for ib in index_b[2]]}

        def sum_matrix_b(getter_from_chk, nd_cart, nb=2):
            """loop over nearest-neighbor vectors and sum the matrix elements
            possibly adding phase factors depending on the lattice vectors R
            and the scheme used

            Parameters
            ----------
            getter_from_chk : callable
                function that returns the matrix elements for a given nearest-neighbor vector(s)
            nd_cart : int
                number of cartesian dimensions of the matrix elements
            nb : int
                number of loops over nearest-neighbor vectors (1 or 2)
            Returns
            -------
            XX_R : np.ndarray
                the matrix elements in real space, shape=(nRvec, num_wann, num_wann) + (3,) * nd_cart
                """
            assert nb in [1, 2], "nb should be 1 or 2"
            shape = (chk.num_kpts, chk.num_wann, chk.num_wann) + (3,) * nd_cart
            if transl_inv_JM:
                phase_loc_i = expiRphase1 if nb == 1 else expiRphase2
                phase_loc_i = np.reshape(phase_loc_i, phase_loc_i.shape + (1,) * nd_cart)
            else:
                phase_loc_i = np.ones((1, 1, 1,) + (NNB,) * nb + (1,) * nd_cart)
            phase_loc_j = expjphase1 if nb == 1 else expjphase2
            phase_loc_j = np.reshape(phase_loc_j, (1,) + phase_loc_j.shape + (1,) * nd_cart)
            shape_R = (system.rvec.nRvec,) + shape[1:]
            XX_R = np.zeros(shape_R, dtype=complex)
            for ib, db in zip(index_b[nb], dict_ib[nb]):
                XX_R[:] += system.rvec.q_to_R(getter_from_chk(**db) * phase_loc_j[:, :, :, *ib]) * phase_loc_i[:, :, :, *ib]
            return XX_R

        bk_cart = w90data.mmn.bk_cart

        if transl_inv_JM:
            _r0 = 0.5 * (centers[:, None, :] + centers[None, :, :])
        else:
            _r0 = centers[None, :, :]

        expjphase1 = np.exp(1j * cached_einsum('ba,ija->ijb', bk_cart, _r0))
        expjphase2 = expjphase1.swapaxes(0, 1).conj()[:, :, :, None] * expjphase1[:, :, None, :]
        kwargs_kpt = {'kptirr': kptirr, 'weights_k': weights_k}

        # A_a(R,b) matrix
        if needed_data.need_any('AA'):
            print("setting AA..")
            getter_from_chk = functools.partial(chk.get_AABB_q_ib,
                                                mmn=w90data.mmn,
                                                transl_inv=transl_inv_MV,
                                                **kwargs_kpt)
            system.set_R_mat('AA',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=1, nb=1),
                            Hermitian=True)

            print("setting AA - OK")


        # B_a(R,b) matrix
        if needed_data.need_any('BB'):
            print("setting BB...")
            getter_from_chk = functools.partial(chk.get_AABB_q_ib,
                                                mmn=w90data.mmn,
                                                eig=w90data.eig,
                                                **kwargs_kpt)
            system.set_R_mat('BB', sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=1, nb=1))
            print("setting BB - OK")


        # C_a(R,b1,b2) matrix
        if needed_data.need_any('CC'):
            print("setting CC..")
            getter_from_chk = functools.partial(chk.get_CCOOGG_ib,
                                                mmn=w90data.mmn,
                                                uhu=w90data.uhu,
                                                antisym=True,
                                                **kwargs_kpt)
            system.set_R_mat('CC',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=1, nb=2),
                            Hermitian=True)
            print("setting CC - OK")


        # O_a(R,b1,b2) matrix
        if needed_data.need_any('OO'):
            print("setting OO..")
            getter_from_chk = functools.partial(chk.get_CCOOGG_ib,
                                                mmn=w90data.mmn,
                                                uhu=w90data.uiu,
                                                antisym=True,
                                                **kwargs_kpt)
            system.set_R_mat('OO',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=1, nb=2),
                            Hermitian=True)
            print("setting OO - ok")


        # G_bc(R,b1,b2) matrix
        if needed_data.need_any('GG'):
            print("setting GG..")
            getter_from_chk = functools.partial(chk.get_CCOOGG_ib,
                                                mmn=w90data.mmn,
                                                uhu=w90data.uiu,
                                                antisym=False,
                                                **kwargs_kpt)
            system.set_R_mat('GG',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=2, nb=2),
                            Hermitian=True)
            print("setting GG - OK")

        #######################################################################

        # by analogy, it looks weird that expiRphase is not applied for SR and SHR
        # TODO : FIXME: check JaeMo's notes to see if it is intended, or overlooked

        if needed_data.need_any('SR'):
            print("setting SR..")
            system.set_R_mat('SR', system.rvec.q_to_R(chk.get_SHR_q(spn=w90data.spn, mmn=w90data.mmn,
                                                                **kwargs_kpt, phase=expjphase1)))
            print("setting SR - Ok")
        if needed_data.need_any('SH'):
            system.set_R_mat('SH',
                            system.rvec.q_to_R(chk.get_SH_q(w90data.spn, w90data.eig, **kwargs_kpt)))
            print("setting SH - Ok")
        if needed_data.need_any('SHR'):
            print("setting SHR..")
            system.set_R_mat('SHR', system.rvec.q_to_R(
                chk.get_SHR_q(spn=w90data.spn, mmn=w90data.mmn,
                              **kwargs_kpt,
                              eig=w90data.eig, phase=expjphase1)))
            print("setting SHR - OK")

        if needed_data.need_any('SA'):
            print("setting SA..")
            getter_from_chk = functools.partial(chk.get_SHA_q,
                                                shu=w90data.siu,
                                                mmn=w90data.mmn,
                                                **kwargs_kpt)
            system.set_R_mat('SA',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=2, nb=1))
            print("setting SA - OK")

        if needed_data.need_any('SHA'):
            print("setting SHA..")
            getter_from_chk = functools.partial(chk.get_SHA_q,
                                                shu=w90data.shu,
                                                mmn=w90data.mmn,
                                                **kwargs_kpt)
            system.set_R_mat('SHA',
                            sum_matrix_b(getter_from_chk=getter_from_chk, nd_cart=2, nb=1))
            print("setting SHA - OK")

        del expjphase1, expjphase2

        if transl_inv_JM:
            recenter_JM(system, centers)


    system.do_at_end_of_init()
    system.check_AA_diag_zero(msg="after conversion of conventions with "
                        f"transl_inv_MV={transl_inv_MV}, transl_inv_JM={transl_inv_JM}",
                            set_zero=transl_inv_MV or transl_inv_JM,
                            threshold=0.1 if transl_inv_JM else 1e5)
    if symmetrize and w90data.has_file('symmetrizer'):
        system.symmetrize2(w90data.symmetrizer)
    return system

    ###########################################################################


def recenter_JM(system, centers):
    """"
    Recenter the matrices in the Jae-Mo scheme
    (only in convention I)

    Parameters
    ----------
    centers : np.ndarray(shape=(num_wann, 3))
        Wannier centers in Cartesian coordinates
    bk_cart : np.ndarray(shape=(num_bk, 3))
        set of nearest-neighbor vectors (cartesian)

    Notes
    -----
    The matrices are recentered in the following way:
    - A_a(R) matrix: no recentering
    - B_a(R) matrix: recentered by the Hamiltonian
    - C_a(R) matrix: recentered by the B matrix
    - O_a(R) matrix: recentered by the A matrix
    - G_bc(R) matrix: no recentering
    - S_a(R) matrix: recentered by the S matrix
    - SH_a(R) matrix: recentered by the S matrix
    - SR_a(R) matrix: recentered by the S matrix
    - SA_a(R) matrix: recentered by the S matrix
    - SHA_a(R) matrix: recentered by the S matrix
    """
    r0 = 0.5 * (centers[None, :, None, :] + centers[None, None, :, :] + system.rvec.cRvec[:, None, None, :])

    # --- A_a(R) matrix --- #
    if system.has_R_mat('AA'):
        AA_R0 = system.get_R_mat('AA').copy()
    # --- B_a(R) matrix --- #
    if system.has_R_mat('BB'):
        BB_R0 = system.get_R_mat('BB').copy()
        HH_R = system.get_R_mat('Ham')
        rc = (r0 - system.rvec.cRvec[:, None, None, :] - centers[None, None, :, :]) * HH_R[:, :, :, None]
        system.set_R_mat('BB', rc, add=True)
    # --- C_a(R) matrix --- #
    if system.has_R_mat('CC'):
        assert BB_R0 is not None, 'Recentered B matrix is needed in Jae-Mo`s implementation of C'
        BB_R0_conj = system.rvec.conj_XX_R(BB_R0)
        rc = 1j * (r0[:, :, :, :, None] - centers[None, :, None, :, None]) * (BB_R0 + BB_R0_conj)[:, :, :, None, :]
        CC_R_add = rc[:, :, :, alpha_A, beta_A] - rc[:, :, :, beta_A, alpha_A]
        system.set_R_mat('CC', CC_R_add, add=True, Hermitian=True)
    if system.has_R_mat('SA'):
        SS_R = system.get_R_mat('SS')
        rc = (r0[:, :, :, :, None] - system.rvec.cRvec[:, None, None, :, None] - centers[None, None, :, :, None]
                ) * SS_R[:, :, :, None, :]
        system.set_R_mat('SA', rc, add=True)
    if system.has_R_mat('SHA'):
        SH_R = system.get_R_mat('SH')
        rc = (r0[:, :, :, :, None] - system.rvec.cRvec[:, None, None, :, None] -
              centers[None, None, :, :, None]) * SH_R[:, :, :, None, :]
        system.set_R_mat('SHA', rc, add=True)
    # --- O_a(R) matrix --- #
    if system.has_R_mat('OO'):
        assert AA_R0 is not None, 'Recentered A matrix is needed in Jae-Mo`s implementation of O'
        rc = 1.j * (r0[:, :, :, :, None] - centers[None, :, None, :, None]) * AA_R0[:, :, :, None, :]
        OO_R_add = rc[:, :, :, alpha_A, beta_A] - rc[:, :, :, beta_A, alpha_A]
        system.set_R_mat('OO', OO_R_add, add=True, Hermitian=True)
    # --- G_bc(R) matrix --- #
    if system.has_R_mat('GG'):
        pass
    print("recentering JM - OK")
