import copy
import numpy as np
from termcolor import cprint
from ..utility import select_window_degen


class EBRsearcher:
    """
    A class  to search for EBRs that cover the frozen window, but fit into the outer window

    Parameters
    ----------
    symmetrizer : `~wannierberri.symmetry.symmetrizer_sawf.SymmetrizerSAWF`
        The file of symmetry properties (only the band part is used, the wann part may be anything or empty)
    froz_min, froz_max : float
        The minimum and maximum energy of the frozen window
    outer_min, outer_max : float
        The minimum and maximum energy of the outer window
    degen_thresh : float
        The threshold to consider bands as degenerate
    trial_projections_set : ProjectionsSet
        The set of trial projections
    debug : bool
        If True, print debug information

    Attributes
    ----------
    eig : np.ndarray(shape=(NKirr,NB), dtype=float)
        The eigenvalues of the bands at irreducible k-points
    nsym_little : list of int (length=NKirr)
        The number of little group symmetries for each irreducible k-point

    Notes
    -----
    * So far it does not work with time-reversal symmetry, and was not tested with spinor wavefuncitons.
      It is recommended to search for projections on a scalar calculation (no spin). 
      The projections found this way are usually good for spinful calculations as well.
    """

    def __init__(self,
                 symmetrizer,
                 frozen=None,
                 outer=None,
                 froz_min=np.inf, froz_max=-np.inf,
                 outer_min=-np.inf, outer_max=np.inf,
                 degen_thresh=1e-8,
                 trial_projections_set=None,
                 debug=False
                ):
        symmetrizer = copy.deepcopy(symmetrizer)
        spacegroup = symmetrizer.spacegroup
        self.eig = symmetrizer.eig_irr.copy()
        assert not spacegroup.spinor, "EBRsearcher does not work with spinors"
        assert len(spacegroup.number_str.split('.')) == 1, f"EBRsearcher works only with non-magnetic spacegroups which are numbered 1-230, not {spacegroup.number_str}"
        assert 0 < int(spacegroup.number_str) <= 230, f"EBRsearcher works only with non-magnetic spacegroups which are numbered 1-230, not {spacegroup.number}"
        assert "magnetic" not in spacegroup.name, "EBRsearcher does not work with magnetic spacegroups"
        assert "unknown" not in spacegroup.name, "EBRsearcher does not work with unknown spacegroups"
        self.NKirr = symmetrizer.NKirr
        self.nsym_little = [len(l) for l in symmetrizer.isym_little]
        self.debug = debug
        self.all_possible_irreps_conj = get_all_possible_irreps_conj(symmetrizer)
        if trial_projections_set is not None:
            self.set_trial_projections_irreps(symmetrizer, trial_projections_set)
        else:
            self.set_irreps_D_wann(symmetrizer)
        self.debug_msg(f"{self.irreps_per_projection_vectors=}")
        self.set_irreps_dft(symmetrizer,
                            frozen=frozen, outer=outer,
                            froz_min=froz_min, froz_max=froz_max,
                            outer_min=outer_min, outer_max=outer_max,
                            degen_thresh=degen_thresh)


    def set_trial_projections_irreps(self, symmetrizer, trial_projections_set):
        symmetrizer.set_D_wann_from_projections(trial_projections_set)
        max_multiplicity = [1 if proj.num_free_vars == 0 else np.inf
                            for proj in trial_projections_set.projections]
        self.set_irreps_D_wann(symmetrizer, max_multiplicity=max_multiplicity)


    def set_irreps_D_wann(self, symmetrizer, max_multiplicity=None):
        from spgrep.representation import get_character
        self.num_trial_projections = symmetrizer.num_D_wann_blocks
        self.debug_msg("detecting irreps generated by each D_wann block",
                       hihglight=True)

        self.num_wann_per_projection = []
        self.proj_max_multiplicity = []

        # find which characters are produced by each projection
        characters_wann = [[] for _ in range(self.NKirr)]

        self.debug_msg(f"{symmetrizer.D_wann_block_indices=} ")
        self.debug_msg(f"{len(symmetrizer.D_wann_blocks)=} ")
        for iproj in range(self.num_trial_projections):
            block_ind = symmetrizer.D_wann_block_indices[iproj]
            num_wann_p = block_ind[1] - block_ind[0]
            char_p = [np.zeros(len(symmetrizer.isym_little[ik]), dtype=complex) for ik in range(self.NKirr)]
            for ik in range(self.NKirr):
                char_p[ik] += get_character([symmetrizer.D_wann_blocks[ik][isym][iproj] for isym in symmetrizer.isym_little[ik]])
            self.num_wann_per_projection.append(num_wann_p)
            for ik in range(self.NKirr):
                characters_wann[ik].append(char_p[ik])
            self.proj_max_multiplicity.append(max_multiplicity[iproj] if max_multiplicity is not None else np.inf)
        characters_wann = [np.array(char) for char in characters_wann]
        self.irreps_per_projection_vectors = []
        for ik in range(self.NKirr):
            vector_wann = char_to_vector(characters_wann[ik], self.all_possible_irreps_conj[ik], froce_int=True)
            self.irreps_per_projection_vectors.append(vector_wann)


    def set_irreps_dft(self, symmetrizer,
                       frozen=None, outer=None,
                       froz_min=np.inf, froz_max=-np.inf,
                       outer_min=-np.inf, outer_max=np.inf,
                       degen_thresh=1e-8):
        self.debug_msg("Detrimine all possible irreps", hihglight=True)
        self.debug_msg(" deternine the irreps in the DFT bands", hihglight=True)
        self.irreps_frozen_vectors = []
        self.irreps_outer_vectors = []
        for ik in range(self.NKirr):
            if frozen is None:
                frozen_ik = select_window_degen(self.eig[ik], thresh=degen_thresh,
                                         win_min=froz_min, win_max=froz_max, return_indices=True)
            else:
                frozen_ik = np.array(frozen[ik])
                if frozen_ik.dtype == bool:
                    frozen_ik = np.where(frozen_ik)[0]
            if outer is None:

                outer_ik = select_window_degen(self.eig[ik], thresh=degen_thresh,
                                     win_min=outer_min, win_max=outer_max, return_indices=True)
            else:
                outer_ik = np.array(outer[ik])
                if outer_ik.dtype == bool:
                    outer_ik = np.where(outer[ik])[0]
            nfrozen = len(frozen_ik)
            char_outer = np.array([symmetrizer.d_band_diagonal(ik, isym)[outer_ik].sum() for isym in symmetrizer.isym_little[ik]])
            char_frozen = np.array([symmetrizer.d_band_diagonal(ik, isym)[frozen_ik].sum() for isym in symmetrizer.isym_little[ik]])
            self.debug_msg(f"ik= {ik} contains {nfrozen} frozen states\n" +
                f"the little group contains {len(symmetrizer.isym_little[ik])} symmetries: \n {symmetrizer.isym_little[ik]}\n" +
                f"characters in outer window : {np.round(char_outer, 3)}\n" +
                f"characters in frozen window: {np.round(char_frozen, 3)}")

            vector_frozen = char_to_vector(char_frozen, self.all_possible_irreps_conj[ik])
            vector_outer = char_to_vector(char_outer, self.all_possible_irreps_conj[ik])

            self.irreps_frozen_vectors.append(vector_frozen)
            self.irreps_outer_vectors.append(vector_outer)
            self.debug_msg(f"Frozen states are represented by vector {vector_frozen}")
            self.debug_msg(f"Outer states are represented by vector {vector_outer}")

            nband_frozen_irreps = np.round(sum(v * irrep[0]
                                      for v, irrep in zip(vector_frozen, self.all_possible_irreps_conj[ik])), 3)
            if nband_frozen_irreps < nfrozen:
                raise RuntimeError("Some frozen bands are not covered by irreps induced by trial projections"
                       "try adding more projections"
                       f"ik={ik} nfrozen={nfrozen} nband_frozen_irreps={nband_frozen_irreps}")
        for i in range(self.NKirr):
            self.debug_msg(f"ik={i} \n frozen={self.irreps_frozen_vectors[i]} \n"
                f" outer={self.irreps_outer_vectors[i]} \n")


    def find_combinations(self, num_wann_min=0, num_wann_max=None, fixed=[]):
        """
        find all possible combinations of trial projections that cover all the irreps inside the frozen window
        and fit into the outer window

        Parameters
        ----------
        num_wann_min, num_wann_max : int
            The minimum and maximum maximum number of wannier functions
        fixed : list of int
            The indices of the trial projections that are fixed and should be taken exactly once

        Returns
        -------
        combinations : np.ndarray(shape=(K,M), dtype=int)
            The K combinations of coefficients that denote multip[licity of each irrep
        """

        lfixed = np.zeros(self.num_trial_projections, dtype=bool)
        lfixed[np.array(fixed, dtype=int)] = True
        print(f"{self.irreps_per_projection_vectors=}, \n{self.irreps_outer_vectors=}, \n{lfixed=}, \n{self.proj_max_multiplicity=}")
        combinations = find_combinations_max(
            vectors=self.irreps_per_projection_vectors[0],
            vector_max=self.irreps_outer_vectors[0],
            num_wann_max=num_wann_max,
            num_wann_per_projection=self.num_wann_per_projection,
            lfixed=lfixed,
            proj_max_multiplicity=self.proj_max_multiplicity,
        )
        num_wann_per_comb = np.dot(combinations, self.num_wann_per_projection)
        combinations = combinations[num_wann_per_comb >= num_wann_min]

        self.debug_msg(f"From first point within outer window {len(combinations)} are valid")
        self.debug_msg(f"{combinations=}")
        iksrt = np.argsort(self.nsym_little)[::-1]  # start from highest symmetry points, because they exclude more
        for ik in iksrt:
            combinations = check_combinations_min_max(combinations=combinations,
                                                      vectors=self.irreps_per_projection_vectors[ik],
                                                      vector_min=self.irreps_frozen_vectors[ik],
                                                      vector_max=self.irreps_outer_vectors[ik])

            self.debug_msg(f"From ik={ik}/{self.NKirr} with frozen and outer window {len(combinations)} are valid")
        return combinations

    def debug_msg(self, msg="", hihglight=False):
        if self.debug:
            if hihglight:
                highlight(msg)
            else:
                print("DEBUG: " + msg)


def find_combinations_max(vectors, vector_max, lfixed,
                          num_wann_max=None,
                          num_wann_per_projection=None,
                          proj_max_multiplicity=None,
                          rec=False):
    """
    Find all combinations of integer coefficients that satisfy the constraints
    sum( c*v for c,v in zip (coeffeicients,vectors) <= vector_max
    for all components of the vectors

    Parameters
    ----------
    vector_max : np.ndarray(shape=(N,), dtype=int)
        The maximum vector
    vectors : np.ndarray(shape=(M,N), dtype=int)
        The vectors
    max_num_wann : int
        The maximum number of wannier functions

    Returns
    -------
    combinations : np.ndarray(shape=(K,M), dtype=int)
        The K combinations of coefficients that denote multiplicity of each irrep
    """
    if num_wann_max is None:
        num_wann_max = np.inf
        num_wann_per_projection = np.ones(vectors.shape[0], dtype=int)
        print("unlimited number of wannier functions")
    else:
        assert num_wann_per_projection is not None, "The number of wannier functions per projection must be specified if max_num_wann is specified"
        assert len(num_wann_per_projection) == vectors.shape[0], "The number of wannier functions per projection must be specified for each projection"
    if proj_max_multiplicity is None:
        proj_max_multiplicity = np.ones(vectors.shape[0], dtype=int) * np.inf
    if vectors.shape[0] == 0:
        return [[]]
    # elif np.any(vector_max < 0):
    #     return []
    else:
        i = 0 if not lfixed[0] else 1
        combinations = []
        while i <= proj_max_multiplicity[0] and np.all(i * vectors[0] <= vector_max) and i * num_wann_per_projection[0] <= num_wann_max:
            for comb in find_combinations_max(vector_max=vector_max - i * vectors[0],
                                              vectors=np.copy(vectors[1:, :]),
                                              lfixed=lfixed[1:],
                                              num_wann_max=num_wann_max - i * num_wann_per_projection[0],
                                              num_wann_per_projection=num_wann_per_projection[1:],
                                              proj_max_multiplicity=proj_max_multiplicity[1:],
                                              rec=True):
                combinations.append([i] + comb)
            if lfixed[0]:
                break
            i += 1
    if not rec:
        combinations = np.array(combinations)
        num_wann_per_comb = np.dot(combinations, num_wann_per_projection)
        srt = np.argsort(num_wann_per_comb)
        combinations = combinations[srt]
    return combinations


def check_combinations_min_max(combinations, vectors, vector_min, vector_max):
    """	
    Find all combinations of integer coefficients that satisfy the constraints
    vector_min <= sum( c*v for c,v in zip (coeffeicients,vectors) <= vector_max

    Parameters
    ----------
    combinations : np.ndarray(shape=(K,M), dtype=int)
        The K trial combinations
    vector_min : np.ndarray(shape=(N,), dtype=int)
        The minimum vector
    vector_max : np.ndarray(shape=(N,), dtype=int)
        The maximum vector
    vectors : np.ndarray(shape=(M,N), dtype=int)
        The vectors

    Returns
    -------
    combinations : np.ndarray(shape=(L,M), dtype=int)
        The L valid combinations (L <= K)
    """
    combinations_new = []
    for comb in combinations:
        dot = np.dot(comb, vectors)
        if (np.all(vector_min <= dot) and np.all(dot <= vector_max)):
            combinations_new.append(comb)
    return combinations_new


def get_irreps(spacegroup,
        kpoint,
        **kwargs
        ):
    r"""Compute all irreducible representations of space group (interface to spgrep)

    Parameters
    ----------
    spacegroup: irrep.spacegroup.Spacegroup
        Space group object
    kpoints: array, (3, )
        Reciprocal vector (in reduced coordinates) of the k-point
    kwargs: dict
        Additional arguments to pass to spgrep.core.get_spacegroup_irreps_from_primitive_symmetry

    Returns
    -------
    irreps: list of Irreps with (little_group_order, dim, dim)
        ``irreps[alpha][i, :, :]`` is the ``alpha``-th irreducible matrix representation of ``(little_rotations[i], little_translations[i])``.
    mapping_little_group: array, (little_group_order, )
        Let ``i = mapping_little_group[idx]``.
        ``(rotations[i], translations[i])`` belongs to the little group of given space space group and kpoint.
    """

    from spgrep.core import get_spacegroup_irreps_from_primitive_symmetry  # , _adjust_phase_for_centering_translations
    from spgrep.representation import get_character
    rotations = [sym.rotation for sym in spacegroup.symmetries]
    translations = [sym.translation for sym in spacegroup.symmetries]

    irreps, mapping_little_group = get_spacegroup_irreps_from_primitive_symmetry(
        rotations=rotations,
        translations=translations,
        kpoint=kpoint,
        method='random',
        **kwargs
    )
    irreps = np.array([get_character(ir) for ir in irreps])  # take only characters
    srt = np.argsort(mapping_little_group)  # not sure if spgrep returns the little group in the same order as the input, so sort it to be sure
    return irreps[:, srt], mapping_little_group[srt]


def char_to_vector(characters, irreps_conj, froce_int=False, atol=1e-3):
    """convert characters to a vector of the number of times each irrep appears

    Parameters
    ----------
    characters : np.ndarray(shape=(...,Nsym_little), dtype=complex)
        The characters of the bands
    irreps_conj : np.ndarray(shape=(Nirr,Nsym_little), dtype=complex)
        The characters of the irreps (conjugated)

    Returns
    -------
    vector : np.ndarray(shape=(...,Nirr), dtype=int)
        The number of times each irrep appears
    """
    nsym = characters.shape[-1]
    assert nsym == irreps_conj.shape[-1], f"the number of symmetries is different {nsym} != {irreps_conj.shape[-1]}"
    vec = np.tensordot(characters, irreps_conj, axes=([-1], [-1])) / nsym
    assert np.allclose(vec.imag, 0, atol=atol), f"the number of irreps is not real {vec.imag}"
    vec = vec.real
    vec_round = np.round(vec.real)
    if froce_int:
        assert np.allclose(vec_round, vec, atol=atol), f"the number of irreps is not integer {vec}"
        return vec_round.astype(int)
    else:
        return np.ceil(np.round(vec, 3)).astype(int)


def highlight(line):
    cprint("#" * 80 + "\n#" + " " * 5 + f"{line}\n" + "#" * 80, color="yellow", attrs=['bold'])


def get_all_possible_irreps_conj(symmetrizer):
    all_possible_irreps_conj = []
    for ik in range(symmetrizer.NKirr):
        kpoint = symmetrizer.kpoints_all[symmetrizer.kptirr[ik]]
        irreps, mapping = get_irreps(spacegroup=symmetrizer.spacegroup, kpoint=kpoint, atol=1e-5)
        assert np.all(mapping == symmetrizer.isym_little[ik]), f"{mapping} != {symmetrizer.isym_little[ik]}"
        all_possible_irreps_conj.append(irreps.conj())
    return all_possible_irreps_conj
