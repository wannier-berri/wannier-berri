from time import time
import numpy as np

from ..symmetry.sawf_kirr import get_symmetrizer_Zirr, get_symmetrizer_Uirr
from ..utility import vectorize, select_window_degen
from ..symmetry.sawf import VoidSymmetrizer
from .wannierizer import Wannierizer


def wannierise(w90data,
               froz_min=np.inf,
               froz_max=-np.inf,
               num_iter=1000,
               conv_tol=1e-9,
               num_iter_converge=3,
               mix_ratio_z=0.5,
               mix_ratio_u=1,
               print_progress_every=10,
               sitesym=False,
               localise=True,
               init="amn",
               num_wann=None,
               parallel=True,
               symmetrize_Z=True,
               irreducible=False
               ):
    r"""
    Performs disentanglement and maximal localization of the bands recorded in w90data.
    The disentanglement is done following the procedure described in `Souza et al., PRB 2001 <https://doi.org/10.1103/PhysRevB.65.035109>`__. 
    The localization is done following a simplified procedure, avoiding gradient descent of the spread functional.

    At the end writes :attr:`w90data.chk.v_matrix` and sets :attr:`w90data.wannierised = True`

    Parameters
    ----------
    w90data: :class:`~wannierberri.w90files.Wannier90data`
        the data
    froz_min : float
        lower bound of the frozen window
    froz_max : float
        upper bound of the frozen window
    num_iter : int
        maximal number of iterations.
    conv_tol : float
        tolerance for convergence of the spread functional  (in :math:`\mathring{\rm A}^{2}`)
    num_iter_converge : int
        the convergence is achieved when the standard deviation of the spread functional over the `num_iter_converge*print_progress_every`
        iterations is less than conv_tol
    mix_ratio_z : float
        0 <= mix_ratio_z <=1  - mixing the Z matrix (disentanglement) from previous itertions. 1 for max speed, smaller values are more stable
    mix_ratio_u : float
        0 <= mix_ratio_u <=1  - mixing the U matrix (localization) from previous itertions. 
        1 for max speed, smaller values are more stable
        WARNING : u<1 at the moment may lead to non-convergence. It is recommended to use mix_ratio_u=1 for now.
    print_progress_every
        frequency to print the progress
    sitesym : bool
        whether to use the site symmetry (Symmetry-adapted Wannier Functions). If True, the symmetrizer attribute should be present in the w90data (either from pw2wannier90 or generated by wabnnierberri
        see  :class:`~wannierberri.symmetry.sawf.SymmetrizerSAWF`, 
        :func:`~wannierberri.symmetry.sawf.SymmetrizerSAWF.from_irrep` and 
        :func:`~wannierberri.symmetry.sawf.SymmetrizerSAWF.set_D_wann_from_projections`
    localise : bool
        whether to perform the localization. If False, only disentanglement and rotation to projections are performed
    kwargs_sitesym : dict
        additional the keyword arguments to be passed to the constructor of the :class:`~wannierberri.wannierise.sitesym.Symmetrizer`
    init : str
        the initialization of the U matrix. "amn" for the current state, "random" for random initialization, "restart" for restarting from the previous state
    num_wann : int
        the number of Wannier functions. Required for random initialization only without sitesymmetry
    parallel : bool
        if True - tries to run in parallel using ray. ray should be initialized before calling this function. If it was not initialized, the function will run in serial mode
    symmetrize_Z : bool
        whether to symmetrize the disentangled Z matrix. If False, the Z matrix is not symmetrized which may lead to inaccuracy and slower convergence, but may be a faster calculation. Use it on your own risk.
    Returns
    -------
    w90data.chk.v_matrix : numpy.ndarray
        the optimized U matrices


    Note
    -----
    * Also sets the following attributes of chk:
        - w90data.chk.v_matrix : numpy.ndarray
            the optimized U matrices
        - w90data.wannierised : bool
            True
        - w90data.chk.wannier_centers_cart : numpy.ndarray (nW,3)
            the centers of the Wannier functions
        - w90data.chk.wannier_spreads : numpy.ndarray (nW)
            the spreads of the Wannier functions

    * If the outer window is needed, use :func:`~wannierberri.w90files.Wannier90data.select_bands` before calling this function. 
    * The function is not parallelized yet 
    * Disentanglement and localization are done in the irreducible BZ (if sitesym=True) and then symmetrized to the full BZ
    * Disentanglement and localization are done together, in the same loop. Therefore only one parameter `num_iter` is used for both

    """

    t0 = time()
    if froz_min > froz_max:
        print("froz_min > froz_max, nothing will be frozen")
    assert 0 < mix_ratio_z <= 1
    NK = w90data.mmn.NK
    if sitesym:
        kptirr = w90data.symmetrizer.kptirr
        symmetrizer = w90data.symmetrizer
        include_k = np.zeros(NK, dtype=bool)
        neighbours = w90data.mmn.neighbours
        for ik in kptirr:
            include_k[ik] = True
            include_k[neighbours[ik]] = True
    else:
        kptirr = np.arange(NK)
        symmetrizer = VoidSymmetrizer(NK=NK)
        include_k = np.ones(NK, dtype=bool)

    frozen = vectorize(select_window_degen, [w90data.eig.data[ik] for ik in kptirr], to_array=True,
                       kwargs=dict(win_min=froz_min, win_max=froz_max))
    free = vectorize(np.logical_not, frozen, to_array=True)

    if init == "amn":
        amn = w90data.amn.data
        w90data.chk.num_wann = w90data.amn.NW
    elif init == "random":
        if sitesym:
            num_wann = symmetrizer.num_wann
        else:
            assert num_wann is not None, "num_wann should be provided for random initialization without sitesymmetry"
        amnshape = (w90data.mmn.NK, w90data.mmn.NB, num_wann)
        amn = np.random.random(amnshape) + 1j * np.random.random(amnshape)
        w90data.chk.num_wann = num_wann
    elif init == "restart":
        assert w90data.wannierised, "The data is not wannierised"
        amn = w90data.chk.v_matrix.copy()
        print("Restarting from the previous state", amn.shape)
    else:
        raise ValueError("init should be 'amn' or 'random'")

    neighbours_all = w90data.mmn.neighbours
    neighbours_irreducible = np.array([[symmetrizer.kpt2kptirr[ikb] for ikb in w90data.mmn.neighbours[ik]]
                                       for ik in kptirr])

    # wk = w90data.mmn.wk_unique
    bk_cart = w90data.mmn.bk_cart
    t1 = time()
    wannierizer = Wannierizer(parallel=parallel, symmetrizer=symmetrizer)
    for ik, kpt in enumerate(kptirr):
        wannierizer.add_kpoint(Mmn=w90data.mmn.data[kpt],
                            frozen=frozen[ik],
                            frozen_nb=frozen[neighbours_irreducible[ik]],
                            wb=w90data.mmn.wk,
                            bk=w90data.mmn.bk_cart,
                            symmetrizer_Zirr=get_symmetrizer_Zirr(symmetrizer, ik, free[ik]) if symmetrize_Z else VoidSymmetrizer(NK=1),
                            symmetrizer_Uirr=get_symmetrizer_Uirr(symmetrizer, ik),
                            ikirr=ik,
                            amn=amn[kpt],
                            weight=symmetrizer.ndegen(ik) / symmetrizer.NK
                            )
    t2 = time()

    # The _IR suffix is used to denote that the U matrix is defined only on k-points in the irreducible BZ
    U_opt_full_IR = wannierizer.get_U_opt_full()
    # the _BZ suffix is used to denote that the U matrix is defined on all k-points in the full BZ
    U_opt_full_BZ = symmetrizer.U_to_full_BZ(U_opt_full_IR, include_k=include_k)

    wannierizer.update_Unb_all([[U_opt_full_BZ[ib] for ib in neighbours_all[kpt]] for kpt in kptirr])

    wcc = wannierizer.wcc
    spreads = wannierizer.spreads
    print_centers_and_spreads(wcc=wcc, spreads=spreads, comment="starting WFs")

    converge_list = []
    delta_std = np.inf
    t_update = 0
    t01 = time()
    for i_iter in range(num_iter):
        wcc_bk_phase = np.exp(1j * wcc.dot(bk_cart.T))
        U_neigh = [[U_opt_full_BZ[ib] for ib in neighbours_all[kpt]] for kpt in kptirr]
        tx = time()
        U_opt_full_IR = wannierizer.update_all(U_neigh, mix_ratio=mix_ratio_z,
                                               mix_ratio_u=mix_ratio_u,
                                               localise=localise,
                                               wcc_bk_phase=wcc_bk_phase)
        t_update += time() - tx

        U_opt_full_BZ = symmetrizer.U_to_full_BZ(U_opt_full_IR, include_k=include_k)

        wcc = wannierizer.wcc
        spreads = wannierizer.spreads
        converge_list.append(np.hstack((wcc, spreads[:, None])))
        delta_std = np.std(converge_list[-num_iter_converge:], axis=0).max()

        if i_iter % print_progress_every == 0:
            print_centers_and_spreads(wcc=wcc, spreads=spreads, comment=f"Iteration {i_iter} (from wannierizer)", std=delta_std)

        if i_iter > num_iter_converge and delta_std < conv_tol:
            print(f"Converged after {i_iter} iterations")
            break

    t02 = time()

    U_opt_full_BZ = symmetrizer.U_to_full_BZ(U_opt_full_IR, include_k=include_k if irreducible else None)
    print_centers_and_spreads(wcc=wcc, spreads=spreads, comment="Final state (from wannierizer)", std=delta_std)
    update_chk(w90data=w90data, U_opt_full_BZ=U_opt_full_BZ, wcc=wcc, spreads=spreads)
    #    comment="Final state (from chk)")
    # if not np.allclose(wcc, wcc_chk, atol=1e-4):
    #     warnings.warn(f"The Wannier centers from the chk file and the Wannier centers from the wannierizer are not the same. diff = {np.abs(wcc - wcc_chk).max()}")
    # if not np.allclose(spreads, spreads_chk, atol=1e-4):
    #     warnings.warn(f"The Wannier spreads from the chk file and the Wannier spreads from the wannierizer are not the same. diff = {np.abs(spreads - spreads_chk).max()}")


    w90data.wannierised = True
    print(f"time for creating wannierizer {t2 - t1}")
    print(f"time for iterations {t02 - t01}")
    print(f"time for updating {t_update}")
    print(f"total time for wannierization {time() - t0}")
    return w90data.chk.v_matrix




def update_chk(w90data, U_opt_full_BZ,
               wcc=None, spreads=None,
               comment="", print_wcc=False):
    """
    print the centers and spreads of the Wannier functions

    Parameters
    ----------
    w90data : Wannier90data
        the data (inputs of wannier90)
    U_opt_free_BZ : list of numpy.ndarray(nBfree,nW)
        the optimized U matrix for the free bands and wannier functions
    """

    w90data.chk.v_matrix = {ik: U for ik, U in enumerate(U_opt_full_BZ) if U is not None}
    if (wcc is None) or (spreads is None):
        wcc_new, spreads_new = w90data.chk.get_wannier_centers(w90data.mmn, spreads=True)
        if wcc is None:
            wcc = wcc_new
        if spreads is None:
            spreads = spreads_new
    w90data.chk.wannier_centers_cart, w90data.chk.wannier_spreads = wcc, spreads
    if print_wcc:
        print_centers_and_spreads(wcc, spreads, comment=comment + ": from chk")
    return wcc, spreads


def print_centers_and_spreads(wcc, spreads, comment=None, std=None):
    """
    print the centers and spreads of the Wannier functions

    Parameters
    ----------
    wcc: np.ndarray(nW,3)
        the centers of the Wannier functions
    spreads: np.ndarray(nW,)
        the spreads of the Wannier functions
    comment: str
        the comment to print
    std: float
        the standard deviation of the spread functional over the last `num_iter_converge` iterations
    set_wcc_chk: bool
        whether to set the wcc and spreads to the chk file
    """
    breakline = "-" * 100
    startline = "#" * 100
    endline = startline
    print(startline)
    if comment is not None:
        print(comment)
        print(breakline)
    print("wannier centers and spreads")
    print(breakline)
    for w, s in zip(wcc, spreads):
        w = np.round(w, 6)
        print(f"{w[0]:16.12f}  {w[1]:16.12f}  {w[2]:16.12f}   |   {s:16.12f}")
    print(breakline)
    w = wcc.sum(axis=0)
    s = np.sum(spreads)
    print((f"{w[0]:16.12f}  {w[1]:16.12f}  {w[2]:16.12f}   |   {s:16.12f} <- sum"))
    print(f"  {' ' * 38}  maximal spread = {np.max(spreads):16.12f}")
    if std is not None:
        print(f"standard deviation = {std}")
    print(endline)


# def print_progress(i_iter, Omega_list, num_iter_converge,
#                    spread_functional=None, spreads=None,
#                    w90data=None, U_opt_full_BZ=None):
#     """
#     print the progress of the wannierisation

#     Parameters
#     ----------
#     Omega_I_list : list of float
#         the list of the spread functional
#     num_iter_converge : int
#         the number of iterations to check the convergence

#     Returns
#     -------
#     float
#         the standard deviation of the spread functional over the last `num_iter_converge` iterations
#     """

#     if spreads is None:
#         assert spread_functional is not None
#         wcc = spread_functional.get_wcc(U_opt_full_BZ)
#         spreads = spread_functional(U_opt_full_BZ, wcc=wcc)

#     Omega_list.append(spreads["Omega_tot"])
#     Omega = Omega_list[-1]
#     if i_iter > 0:
#         delta = f"{Omega - Omega_list[-2]:15.8e}"
#     else:
#         delta = "--"

#     if len(Omega_list) > num_iter_converge:
#         delta_max = np.abs(Omega_list[-num_iter_converge:] - np.mean(Omega_list[-num_iter_converge:])).max()
#         delta_max_str = f"{delta_max:15.8e}"
#         slope = (Omega_list[-1] - Omega_list[-num_iter_converge - 1]) / num_iter_converge
#         slope_str = f"{slope:15.8e}"
#     else:
#         delta_max = np.inf
#         delta_max_str = "--"
#         slope_str = "--"

#     comment = f"iteration {i_iter:4d} Omega= {Omega:15.10f}  delta={delta}, max({num_iter_converge})={delta_max_str}, slope={slope_str}"
#     print_centers_and_spreads(w90data, U_opt_full_BZ, spreads=spreads, comment=comment)
#     sys.stdout.flush()
#     return delta_max
